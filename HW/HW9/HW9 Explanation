The purpose of this code is to find the lowest common ancestor given 2 nodes p and q within a BST. The first thing we can do is to set a base case to make sure that root, p, or q are null. If the root is null, then either we are at a dead end or the BST is empty. If p or q are null then we have no way of finding the ancestor as we are unable to figure out where they are using our comparison methods. In both cases, we return null. We then have a pair of else if statements. The way that the BST works is that if two values were to share a lower common ancestor than the current root node, then they will both be on the same side of the BST, either the left side or the right side. From this, we can use an if statement to compare if they are both less than the current node (on the left side of the BST) or both greater than the current node (on the right side of the BST). From there, we can recursively call the method with the left or right child as the current node, effectively travelling down the BST and getting closer to the lowest common ancestor. Once neither of the else if statements are true, we can return root in an else statement. Once we get to this point, where p and q are neither both greater than or both less than the current node, we know that the current node is the lowest common ancestor.

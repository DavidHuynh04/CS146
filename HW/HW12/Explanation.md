The way this code works is to first identify all of the cases where building a well would be cheaper than building a pipe. For the purposes of this assignment, there is no advantage to building a pipe over a well if they are the same cost. In order to do this I built an array called cheapest pipe, which was filled with the cost of the wells for each house. The array is n+1 size, as I don't access 0 and start at 1 in order to match the house number, since houses are not 0-indexed. I then iterated through pipes, and checked to see if either house had a pipe cost that was cheaper than the well. If it was cheaper, I would update the cheapest pipe array to that value. The next step is to check a house's well cost vs the cheapest edge array. If the well was less than or equal to the cheapest edge, then that would mean that the well is cheaper than the house's edges, so we can build a well at that house. To represent building the well, we can add the well cost, and add the house to a visited list. In the case that the well is more expensive than the cheapest edge, we skip over it as it is not cost effective. In order to account for the edge case of there being no well that is cheaper than any edges, we will check to see if there is no house in the visited list, and then iterate through the well array to only add the cheapest well, and add it's house to the visited list. 
Now that we have all of our effective wells, we can start adding pipes between the houses. To do this I implemented Prim's algorithm but less effective. Instead of using an adjacency list, I just sorted the pipes by cheapest cost, and then iterated through the array to find the first pipe that was connected to exactly one house in the visited array. By doing this I ensured that every pipe added was connected to a well, as well as making sure that no pipes connected already visited houses. After finding the cheapest pipe, I would add the unvisited house to the visited array, and add the cost. In order to account for if I added a visited house, which had a pipe earlier in the array that I could now access, I would break the loop and restart it from the beginning to check if there are any pipes to add that now connected a visited house. All of this is in a while loop, which makes sure that the code continues finding the cheapest pipe until all the houses are visited. While it is inefficient to do it this way, this was the easiest way to visualize while accounting for edge cases.
